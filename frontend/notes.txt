âœ… Goal of this Phase
Set up a pro-level project architecture.
Use the latest and most efficient tools for better developer experience and productivity.
Implement a proper folder structure from the beginning.
Configure Tailwind CSS for rapid styling and consistency.
Add ESLint & Prettier for code consistency and linting.

ğŸ’¡ ğŸ“Œ Tech Stack & Tools
âœ… Frontend: React + Vite
âœ… Styling: Tailwind CSS (for a modern, responsive UI)
âœ… State Management: Redux Toolkit
âœ… Data Fetching: Axios
âœ… AI Tools:

Code GPT: For code explanations and instant fixes.
Zustand Inspector: For Redux state visualization.
âœ… Extensions:
ESLint + Prettier â†’ For consistent code formatting.
Tailwind IntelliSense â†’ For Tailwind autocomplete and previews.
âœ… Testing:
Jest + React Testing Library (in later phases for unit tests).



ğŸš€ 1ï¸âƒ£ Initializing the Project
âœ… We'll use Vite instead of Create React App for better performance and faster build times.

ğŸ”¹ Step 1: Create Vite + React Project
bash
Copy
Edit
npm create vite@latest frontend -- --template react
cd frontend
âœ… Install dependencies:

bash
Copy
Edit
npm install
âœ… Install essential packages:

bash
Copy
Edit
npm install react-router-dom axios @reduxjs/toolkit react-redux
âœ… Install Tailwind CSS:

bash
Copy
Edit
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
âœ… Enable Tailwind in tailwind.config.js:

javascript
Copy
Edit
// tailwind.config.js
export default {
  content: ["./index.html", "./src/**/*.{js,jsx}"],
  theme: {
    extend: {},
  },
  plugins: [],
};
âœ… Configure index.css:

css
Copy
Edit
@tailwind base;
@tailwind components;
@tailwind utilities;
ğŸ”¥ 2ï¸âƒ£ Folder Structure & Architecture
âœ… Goal: Create a modular, scalable structure from the start for clean and maintainable code.

csharp
Copy
Edit
ğŸ“ frontend
 â”œâ”€â”€ ğŸ“ public          # Static assets
 â”œâ”€â”€ ğŸ“ src
 â”‚   â”œâ”€â”€ ğŸ“ assets      # Images, icons, styles
 â”‚   â”œâ”€â”€ ğŸ“ components  # Reusable components
 â”‚   â”‚       â”œâ”€â”€ Navbar.jsx
 â”‚   â”‚       â”œâ”€â”€ Sidebar.jsx
 â”‚   â”‚       â”œâ”€â”€ StatsCard.jsx
 â”‚   â”‚       â”œâ”€â”€ Chart.jsx
 â”‚   â”‚       â”œâ”€â”€ ActivityTable.jsx
 â”‚   â”œâ”€â”€ ğŸ“ pages       # Main pages
 â”‚   â”‚       â”œâ”€â”€ Dashboard.jsx
 â”‚   â”‚       â”œâ”€â”€ ActivityLog.jsx
 â”‚   â”‚       â”œâ”€â”€ Settings.jsx
 â”‚   â”œâ”€â”€ ğŸ“ store       # Redux state management
 â”‚   â”‚       â”œâ”€â”€ activitySlice.js
 â”‚   â”‚       â”œâ”€â”€ store.js
 â”‚   â”œâ”€â”€ ğŸ“ hooks       # Custom hooks
 â”‚   â”‚       â”œâ”€â”€ useFetchActivities.js
 â”‚   â”œâ”€â”€ ğŸ“ utils       # Helper functions
 â”‚   â”‚       â”œâ”€â”€ api.js
 â”‚   â”‚       â”œâ”€â”€ dateFormatter.js
 â”‚   â”œâ”€â”€ App.jsx
 â”‚   â”œâ”€â”€ main.jsx
 â”‚â”€â”€ tailwind.config.js
 â”‚â”€â”€ package.json
 â”‚â”€â”€ .eslintrc.json      # Linter configuration
 â”‚â”€â”€ .prettierrc.json    # Code formatting rules
âœ… 3ï¸âƒ£ Linting & Code Formatting
ğŸ’¡ Why use ESLint & Prettier?

Enforces consistent code style.
Catches potential bugs and issues.
Improves readability and maintainability.
ğŸ”¹ Install ESLint & Prettier
bash
Copy
Edit
npm install -D eslint prettier eslint-plugin-react eslint-config-prettier eslint-plugin-prettier
ğŸ”¹ Create .eslintrc.json
json
Copy
Edit
{
  "env": {
    "browser": true,
    "es2021": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:react/recommended",
    "prettier"
  ],
  "plugins": ["react", "prettier"],
  "rules": {
    "prettier/prettier": ["error"],
    "react/prop-types": "off",
    "no-unused-vars": "warn"
  }
}
ğŸ”¹ Create .prettierrc.json
json
Copy
Edit
{
  "semi": true,
  "singleQuote": false,
  "tabWidth": 2,
  "trailingComma": "es5"
}
âœ… Add formatting scripts in package.json:

json
Copy
Edit
"scripts": {
  "lint": "eslint ./src --ext .js,.jsx",
  "format": "prettier --write ./src"
}
ğŸ› ï¸ 4ï¸âƒ£ Global Styles & Theme Configuration
ğŸ’¡ Why?

Maintain a consistent UI theme with reusable Tailwind classes.
Use CSS variables for color consistency.
âœ… src/assets/styles.css:

css
Copy
Edit
:root {
  --primary-color: #4f46e5;
  --secondary-color: #22c55e;
  --text-color: #374151;
}

@layer base {
  body {
    @apply bg-gray-50 text-gray-800;
  }

  h1, h2, h3, h4, h5 {
    @apply font-bold;
  }

  button {
    @apply bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 transition;
  }
}
ğŸ”¥ 5ï¸âƒ£ AI Tools for Development
ğŸš€ Recommended Tools
Code GPT (VS Code Extension)
Provides code explanations and auto-fixes directly in the IDE.
Zustand Inspector
Inspects Redux state visually for easy debugging.
Tailwind IntelliSense
Autocompletes Tailwind classes with real-time previews.
âœ… Install them in VS Code to boost productivity.

âœ… 6ï¸âƒ£ Running the Project
Start the project with:

bash
Copy
Edit
npm run dev
Your frontend should be up and running at:
ğŸ‘‰ http://localhost:5173

ğŸš€ ğŸ¯ Phase 1 Achievements
âœ… Pro-level project structure â†’ Scalable and modular.
âœ… Tailwind CSS â†’ Rapid styling with reusable components.
âœ… ESLint & Prettier â†’ Code quality enforcement.
âœ… AI Tools â†’ Faster development with assistance.




ğŸ¯ ğŸ”¥ Phase 2: State Management with Redux
âœ… Goal of this Phase
Integrate Redux Toolkit (RTK) for centralized and optimized state management.

Use Redux Thunks to handle asynchronous operations for fetching data.

Store, update, and manage app activity data efficiently.

Structure the Redux store cleanly with slices and async operations.

Prepare the frontend to send and receive activity data from the backend.

ğŸ’¡ ğŸ“Œ Why Redux Toolkit (RTK)?
âœ… Simplifies Redux development by reducing boilerplate code.
âœ… Built-in support for thunks â†’ Easy async operations.
âœ… Automatically uses Immer for immutable state updates.
âœ… Better debugging and DevTools integration.
âœ… Redux Query (RTK Query) â†’ Simplified data fetching (we'll add this later).

ğŸš€ 1ï¸âƒ£ Setting Up Redux Store
ğŸ”¥ ğŸ”¹ Step 1: Install Redux Toolkit
If you haven't installed it already, run:

bash
Copy
Edit
npm install @reduxjs/toolkit react-redux
âœ… Folder structure after adding Redux:

bash
Copy
Edit
ğŸ“ src
 â”œâ”€â”€ ğŸ“ store            # Redux state management
 â”‚       â”œâ”€â”€ store.js         # Store configuration
 â”‚       â”œâ”€â”€ activitySlice.js # Redux slice for activity data
 â”‚       â”œâ”€â”€ apiSlice.js      # Redux slice for backend API
 â”‚â”€â”€ ğŸ“ components
 â”‚â”€â”€ ğŸ“ pages
 â”‚â”€â”€ App.jsx
 â”‚â”€â”€ main.jsx
ğŸ”¥ ğŸ”¹ Step 2: Configure the Redux Store
âœ… Create the store.js: ğŸ“Œ src/store/store.js

javascript
Copy
Edit
import { configureStore } from "@reduxjs/toolkit";
import activityReducer from "./activitySlice";
import apiReducer from "./apiSlice";

const store = configureStore({
  reducer: {
    activity: activityReducer,   // Local activity data
    api: apiReducer              // Backend communication
  },
});

export default store;
âœ… Wrap the App with the Redux Provider ğŸ“Œ src/main.jsx

javascript
Copy
Edit
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.jsx";
import { Provider } from "react-redux";
import store from "./store/store.js";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>
);
ğŸš€ 2ï¸âƒ£ Activity Slice for Local State Management
ğŸ’¡ This slice will:
âœ… Store activity data fetched from the local storage or backend.
âœ… Handle CRUD operations and data normalization.
âœ… Manage the loading and error states.

âœ… Create the activitySlice.js: ğŸ“Œ src/store/activitySlice.js

javascript
Copy
Edit
import { createSlice } from "@reduxjs/toolkit";

const initialState = {
  activities: [],     // Store activity data
  loading: false,      // Loading indicator
  error: null,         // Store errors
};

const activitySlice = createSlice({
  name: "activity",
  initialState,
  reducers: {
    setActivities: (state, action) => {
      state.activities = action.payload;
    },
    addActivity: (state, action) => {
      state.activities.push(action.payload);
    },
    setLoading: (state, action) => {
      state.loading = action.payload;
    },
    setError: (state, action) => {
      state.error = action.payload;
    },
  },
});

export const { setActivities, addActivity, setLoading, setError } = activitySlice.actions;
export default activitySlice.reducer;
ğŸš€ 3ï¸âƒ£ API Slice with Async Thunks
ğŸ’¡ Why?
âœ… To perform async operations (fetching data from backend) using Redux Thunks.
âœ… Store API responses in Redux state.
âœ… Handle loading and error states efficiently.

âœ… Create the apiSlice.js: ğŸ“Œ src/store/apiSlice.js

javascript
Copy
Edit
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import axios from "axios";

const BACKEND_URL = "https://your-backend.onrender.com/api/usage";

// Async thunk to fetch activity data from the backend
export const fetchActivities = createAsyncThunk(
  "api/fetchActivities",
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get(`${BACKEND_URL}/daily`);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response.data);
    }
  }
);

const apiSlice = createSlice({
  name: "api",
  initialState: {
    data: [],
    loading: false,
    error: null,
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchActivities.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchActivities.fulfilled, (state, action) => {
        state.loading = false;
        state.data = action.payload;
      })
      .addCase(fetchActivities.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

export default apiSlice.reducer;
ğŸš€ 4ï¸âƒ£ Triggering API Calls & Redux Integration
âœ… To fetch and store activity data when the Dashboard mounts.
âœ… Handle loading and errors with clean UI feedback.

âœ… src/pages/Dashboard.jsx:

javascript
Copy
Edit
import React, { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { fetchActivities } from "../store/apiSlice";
import Loader from "../components/Loader";

const Dashboard = () => {
  const dispatch = useDispatch();
  const { data, loading, error } = useSelector((state) => state.api);

  useEffect(() => {
    dispatch(fetchActivities());  // Fetch data on mount
  }, [dispatch]);

  if (loading) return <Loader />;
  if (error) return <p className="text-red-500">Error: {error}</p>;

  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold mb-4">Activity Dashboard</h1>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        {data.map((item, index) => (
          <div key={index} className="bg-white shadow p-4 rounded-lg">
            <p><strong>App:</strong> {item.app}</p>
            <p><strong>Title:</strong> {item.title}</p>
            <p><strong>Duration:</strong> {item.duration} seconds</p>
            <p><strong>Date:</strong> {item.date}</p>
          </div>
        ))}
      </div>
    </div>
  );
};

export default Dashboard;
âœ… 5ï¸âƒ£ Components & Reusability
ğŸ’¡ Goal:

Create reusable components for better maintainability.

Display data with cards, tables, and charts.

Handle loading and error states gracefully.

âœ… Create a reusable Loader.jsx:

javascript
Copy
Edit
import React from "react";

const Loader = () => {
  return (
    <div className="flex justify-center items-center min-h-screen">
      <div className="animate-spin rounded-full h-12 w-12 border-t-4 border-blue-500"></div>
    </div>
  );
};

export default Loader;
ğŸ¯ ğŸ”¥ Phase 2 Achievements
âœ… Redux-powered state management â†’ Efficient and centralized.
âœ… Async data fetching with Thunks â†’ Cleanly handling async operations.
âœ… Modular architecture â†’ Easily scalable.
âœ… Reusable components â†’ Cleaner and faster UI development.



âœ… Switch to pnpm â†’ For long-term stability and better dependency management


Why We Use Error Boundaries
Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the entire application. They work like JavaScript catch {} blocks, but for components.

Key Reasons to Use Error Boundaries:
Prevent Complete App Crashes
Without error boundaries, a single error in any component can break your entire application.

Better User Experience
Instead of seeing a blank screen or broken UI, users see a friendly error message.

Error Logging
You can log errors to your error reporting service (like Sentry) in the componentDidCatch method.

Isolate Problems
Errors in one part of the UI won't affect unrelated components.









